<html>
<head>
  <title>Laborator</title>
  <link rel="stylesheet" type="text/css" href="stiluri.css" />
  <!-- pentru diacritice -->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h2><font color="blue">Laborator #9 :</font> exerciții de antrenament</h2>

<!------------------------------------------------------------------------------------------------------------------------>
<hr size="3" width="100%" noshade>
<!------------------------------------------------------------------------------------------------------------------------>
<p><span class="stil_exercitii">Exerciții de programare C cu mai multe procese :</span></p>

<p>
1. <big>[Șablonul 'ping-pong']</big>
Scrieți un program C care să creeze un proces fiu cu care să înceapă să discute conform unui dialog salvat în două fișiere,
câte unul pentru fiecare vorbitor: parinte.txt și respectiv fiu.txt.
Discuția se va purta ca la un dialog normal: fiecare vorbitor va spune o replică, după care va aștepta răspunsul celuilalt.
Așteptarea răspunsului celuilalt se va încheia cu ajutorul unui flag, păstrat în fișierul comunicare.txt, care se va seta într-un mod adecvat,
de către celălalt proces, după ce și-a spus replica.
<br>
(Indicație: <span class="stil_hint">ideea este de a implementa corect un mecanism de sincronizare de forma "e rândul tău - e rândul meu - e rândul tău - e rândul meu - ș.a.m.d.",
folosind comunicații prin intermediul unui fișier.
<br>
<i>Observație</i>: mai târziu vom relua ideea acestui șablon de sincronizare, folosind canale de comunicație, respectiv semnale.</span>)
</p>

<p>
2. <big>[Șablonul 'supervisor-workers']</big>
Scrieți un program C care primește ca argument o valoare numerică <tt>N</tt> și creează două procese fii;
primul proces fiu va scrie <tt>N</tt> perechi de numere întregi într-un fișier binar "operanzi.bin",
iar al doilea fiu va genera <tt>N</tt> caractere de tipul '+', '-', '*', '/' într-un fișier text "operatori.txt".
Procesul părinte va aștepta generarea celor două fișiere de către fii, apoi
va citi succesiv câte o pereche de numere din fișierul "operanzi.bin" și câte o operație din fișierul "operatori.txt",
va efectua calculul respectiv și va afișa pe ecran rezultatele operațiilor efectuate. 
<br>
(Indicație: <span class="stil_hint">ideea este de a implementa un calcul paralel/distribuit pe modelul "supervisor-workers" (sau "master-slaves").
<br>
<i>Observație</i>: un alt exemplu, mai elaborat, de realizare a unui calcul de această formă, din care vă puteți inspira, îl găsiți în directorul cu programele demonstrative
de la lecția practică <a href="../cursuri/P6_fork+wait.pdf">P6_fork+wait</a>.</span>)
<p>

<!------------------------------------------------------------------------------------------------------------------------>
<p class="stil_ex_suplimentare">Exerciții suplimentare:</p>

<p>Alte câteva exerciții de programare C cu mai multe procese:</p> 

<p>
3. <big>[N fii]</big>
Să se scrie un program C care să creeze <tt>N</tt> (unde <tt>N</tt> este o valoare citită de la tastatură) procese fii ai procesului inițial.
Și anume, procesul inițial P<sub>0</sub> va avea ca fii procesele P<sub>1</sub>, P<sub>2</sub>, ..., P<sub><tt>N</tt></sub>, iar acestea nu vor avea nici un fiu.
Fiecare proces își va tipări, printr-un singur mesaj, numărul lui de ordine ca fiu sau proces inițial, PID-ul lui și pe cel al părintelui său.
<br>
Scrieți o rezolvare nerecursivă a acestei probleme (i.e. folosiți o buclă iterativă pentru crearea proceselor).
</p>

<p>
4. <big>[Lista de procese (iterativă)]</big>
Să se scrie un program C care să creeze o listă de procese de lungime <tt>N</tt> (unde <tt>N</tt> este o valoare citită de la tastatură).
Și anume, procesul P<sub>1</sub> va avea ca fiu pe procesul P<sub>2</sub>, acesta la rândul lui îl va avea ca fiu pe procesul P<sub>3</sub>, ș.a.m.d. până la
procesul P<sub><tt>N</tt></sub>, care nu va avea nici un fiu.
Fiecare proces își va tipări, printr-un singur mesaj, numărul lui de ordine în listă, PID-ul lui, pe cel al părintelui său, precum și PID-ul fiului său și codul
acestuia de terminare.
<br>
Scrieți o rezolvare nerecursivă a acestei probleme (i.e. folosiți o buclă iterativă pentru crearea proceselor).
</p>

<p>
5. <big>[Lista de procese (recursivă)]</big>
Să se elaboreze o soluție recursivă a problemei anterioare (i.e. scrieți o funcție recursivă pentru crearea proceselor).
</p>

<p>
6. <big>[Arborele de procese (recursiv)]</big>
Să se scrie un program C care să creeze un arbore <tt>K</tt>-ar complet cu <tt>N</tt> nivele, de procese (valorile <tt>K</tt> și <tt>N</tt> vor fi citite de la tastatură).
Și anume: unicul proces P<sub>1,1</sub> de pe nivelul 1 al arborelui (i.e., rădăcina arborelui) va avea <tt>K</tt> procese fii, și anume
procesele P<sub>2,1</sub>,...,P<sub>2,<tt>K</tt></sub> de pe nivelul 2 al arborelui,
fiecare dintre acestea va avea la rândul său <tt>K</tt> procese fii pe nivelul 3 al arborelui, ș.a.m.d.
până la cele <tt>K</tt><sup><tt>N</tt>-1</sup> procese de pe nivelul <tt>N</tt> al arborelui, care nu vor avea nici un fiu.
<br>
Fiecare proces își va tipări, printr-un singur mesaj, numărul lui de ordine în arbore (i.e. perechea i,j cu 1&le;i&le;<tt>N</tt> și 1&le;j&le;<tt>K</tt><sup>i-1</sup>),
PID-ul lui, pe cel al părintelui său, precum și PID-urile celor <tt>K</tt> fii ai acestuia și codurile acestora de terminare.
<br>
Scrieți o rezolvare recursivă a acestei probleme (i.e. folosiți o funcție recursivă pentru crearea proceselor), astfel:
<br>
i) prin recursie după <tt>K</tt> si <tt>N</tt> ; sau ii) prin recursie doar după <tt>N</tt> .
</p>

<p>
<b><i>Recomandare</i>:</b>
Pentru a vă testa programul, în sensul de a verifica dacă într-adevăr creează în mod corect arborele de procese conform enunțului, într-o manieră mai ușoară
decât prin interpretarea mesajelor afișate pe ecran prin execuția programului, vă recomand să desenați pe o foaie de hârtie PID-urile proceselor afișate și
să le conectați prin săgeți care să indice relația părinte--&gt;fiu.
Desenul care rezultă ar trebui să arate ca un arbore <tt>K</tt>-ar complet cu <tt>N</tt> nivele, în cazul în care nu ați făcut greșeli în program,
iar dacă arată altfel, diferențele v-ar putea ajuta să descoperiți ce greșeli ați făcut în program.
<br><i>Notă</i>: evident, aceeași recomandare este valabilă și pentru problemele anterioare 1, 2 și 3 (deși în cazul acestora ierarhia de procese fiind mult
mai simplă, se poate verifica mai ușor direct prin interpretarea mesajelor afișate pe ecran prin execuția programului respectiv).
<br>
O altă posibilitate de a verifica, fără a mai desena manual pe o foaie de hârtie, este să folosiți un script bash care "desenează" în mod automatizat
pe ecran arborele de procese; mai multe detalii despre acest script puteți citi <a href="lab9p2ls_sh.txt">aici</a>.
</p>

<p>
7. <big>[Arborele de procese (iterativ)]</big>
Să se elaboreze o soluție iterativă a problemei anterioare (i.e. folosiți bucle iterative pentru crearea proceselor).
</p>

<p>
8. Să se implementeze algoritmul de sortare <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort</a>
lucrând pe un fișier ce conține numere stocate în format binar, folosind lacăte pe secțiuni de fișier (ca și la exercițiile din laboratorul precedent),
însă, în loc de lansări simultane în execuție ale programului de forma:
<br>
<tt>UNIX> ./mergesort 1 &amp; ./mergesort 2 &amp; ./mergesort 3 &amp; ...</tt> ,
<br>
să se folosească procese create cu apeluri fork (deci va fi suficientă o singură lansare în execuție a programului).
<br>Practic, se va crea un arbore binar de procese, "frunzele" făcând comparațiile și inversiunile propriu-zise,
iar apoi procesele părinte realizează interclasarea secțiunilor ordonate de procesele copii.
</p>


<!------------------------------------------------------------------------------------------------------------------------>
<hr size="3" width="100%" noshade>

</body>
</html>